package gotime

import (
	"fmt"
	"time"
)

func ParseTimeString(ts string, useLocalTime ...bool) (time.Time, error) {
	layouts := []string{
		"2006-01-02T15:04:05.999999999",
		"2006-01-02 15:04:05.999999999",
		"2006-01-02",
		"2006/01/02T15:04:05.999999999",
		"2006/01/02 15:04:05.999999999",
		"2006/01/02",

		"2006-01-02T15:04:05.999999999Z07:00", // RFC3339
		"2006-01-02T15:04:05.999999999Z0700",
		"2006-01-02 15:04:05.999999999Z07:00",
		"2006-01-02 15:04:05.999999999Z0700",
		"2006-01-02T15:04:05.999999999 -07:00",
		"2006-01-02T15:04:05.999999999 -0700",
		"2006-01-02 15:04:05.999999999 -07:00",
		"2006-01-02 15:04:05.999999999 -0700",
		"2006/01/02T15:04:05.999999999Z07:00",
		"2006/01/02T15:04:05.999999999Z0700",
		"2006/01/02 15:04:05.999999999Z07:00",
		"2006/01/02 15:04:05.999999999Z0700",
		"2006/01/02T15:04:05.999999999 -07:00",
		"2006/01/02T15:04:05.999999999 -0700",
		"2006/01/02 15:04:05.999999999 -07:00",
		"2006/01/02 15:04:05.999999999 -0700",

		"2006-01-02Z07:00",
		"2006-01-02Z0700",
		"2006-01-02 -07:00",
		"2006-01-02 -0700",
		"2006/01/02Z07:00",
		"2006/01/02Z0700",
		"2006/01/02 -07:00",
		"2006/01/02 -0700",
	}

	var t time.Time
	for idx, layout := range layouts {
		t, err := time.Parse(layout, ts)
		if err == nil {
			if idx < 6 {
				var loc *time.Location
				if len(useLocalTime) > 0 && useLocalTime[0] {
					loc = time.Now().Location()
				} else {
					loc, _ = time.LoadLocation("")
				}
				t, _ = time.ParseInLocation(layout, ts, loc)
			}
			return t, nil
		}
	}

	return t, fmt.Errorf("cannot parse time string %s", ts)
}

